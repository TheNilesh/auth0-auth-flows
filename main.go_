package main

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"

	"github.com/joho/godotenv"
)

// Define a struct for the query parameters
type AuthRequest struct {
	Scope               string
	ResponseType        string
	ClientID            string
	RedirectURI         string
	CodeChallenge       string
	CodeChallengeMethod string
}

func main() {
	codeVerifier, err := generateRandomString(64) // Generating a 64 byte length random string
	if err != nil {
		fmt.Println("Error generating code verifier:", err)
		return
	}

	codeChallenge, err := generateCodeChallenge(codeVerifier)
	if err != nil {
		fmt.Println("Error generating code challenge:", err)
		return
	}

	fmt.Println("Code Verifier:", codeVerifier)
	fmt.Println("Code Challenge:", codeChallenge)

	if err := godotenv.Load(); err != nil {
		log.Fatal("Error loading .env file")
	}

	// Initialize the struct with values from environment variables
	req := AuthRequest{
		Scope:               "openid email profile offline_access",
		ResponseType:        "code",
		ClientID:            os.Getenv("AUTH0_CLIENT_ID"),
		RedirectURI:         os.Getenv("AUTH0_REDIRECT_URI"),
		CodeChallenge:       codeChallenge,
		CodeChallengeMethod: "S256",
	}
	os.Setenv("CODE_VERIFIER", codeVerifier)

	// Generate the URL using fmt.Sprintf
	url := fmt.Sprintf(
		"https://dev-y4iktpeh0etjffdi.us.auth0.com/authorize?scope=%s&response_type=%s&client_id=%s&redirect_uri=%s&code_challenge=%s&code_challenge_method=%s",
		url.QueryEscape(req.Scope),
		url.QueryEscape(req.ResponseType),
		url.QueryEscape(req.ClientID),
		url.QueryEscape(req.RedirectURI),
		url.QueryEscape(req.CodeChallenge),
		url.QueryEscape(req.CodeChallengeMethod),
	)

	// Print the generated URL
	fmt.Println("Click this URL:", url)

	// Set up a simple HTTP server
	http.HandleFunc("/", callbackHandler)
	log.Println("Starting server on http://localhost:3000")
	log.Fatal(http.ListenAndServe(":3000", nil))
}

func callbackHandler(w http.ResponseWriter, r *http.Request) {
	// Parse the query parameters from the callback URL
	err := r.ParseForm()
	if err != nil {
		http.Error(w, "Failed to parse form", http.StatusInternalServerError)
		return
	}

	// Log the authorization code and any tokens received
	authCode := r.FormValue("code")
	if authCode != "" {
		log.Println("Received Authorization Code:", authCode)
		go getTokens(authCode)
		return
	}
	accessToken := r.FormValue("access_token")
	refreshToken := r.FormValue("refresh_token")
	idToken := r.FormValue("id_token")
	log.Printf("Access Token: %s\n", accessToken)
	log.Printf("Refresh Token: %s\n", refreshToken)
	log.Printf("ID Token: %s\n", idToken)
}

func getTokens(authCode string) {
	// Make a POST request to the authorization server to exchange the authorization code for tokens
	resp, err := http.PostForm("https://dev-y4iktpeh0etjffdi.us.auth0.com/oauth/token", url.Values{
		"grant_type":    {"authorization_code"},
		"code":          {authCode},
		"client_id":     {os.Getenv("AUTH0_CLIENT_ID")},
		"redirect_uri":  {os.Getenv("AUTH0_REDIRECT_URI")},
		"code_verifier": {os.Getenv("CODE_VERIFIER")},
	})
	if err != nil {
		log.Fatal("Failed to exchange authorization code for tokens")
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatal("Failed to read response body")
	}
	log.Printf("Response Body: %s\n", body)
}

func generateRandomString(length int) (string, error) {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~"
	b := make([]byte, length)
	if _, err := rand.Read(b); err != nil {
		return "", err
	}
	for i := range b {
		b[i] = charset[int(b[i])%len(charset)]
	}
	return string(b), nil
}

func generateCodeChallenge(codeVerifier string) (string, error) {
	hasher := sha256.New()
	if _, err := hasher.Write([]byte(codeVerifier)); err != nil {
		return "", err
	}
	hash := hasher.Sum(nil)
	return base64.RawURLEncoding.EncodeToString(hash), nil
}
